
CODE TEMPLATE OVERVIEW:

The robot terminal runs Robot.java which is in src folder and then in the java folder
	RobotInit is run whenever the robot boots up while connected to the system
		Button bindings are set in this function through the robotContainer object
	RobotPeriodic is run every 20ms and is uused for polling buttons and the like
	DIsabledInit is run every time the virtual machine sent to the robot enters disabled mode
	DidabledPeriodic is poled evvery 20ms when the VM is disabled
	autonomousInit runs whatever autonomous commands are selected in the RobotContainer class
	autonomousPeriodic is called every 20ms during autonomous round
	teleopInit ensures that the autonomous program stops once the human operation phase begins
	teleopPeriodic is called on every 20ms during the operator control time
	testInit cancels all other commands at the start of test mode
	testPeriodic is periodically called on during test mode
	simulationInit is called once the robot is first started up
	simulationPeriodicc is called every 20ms during simulation
All global variables are stored in Constants.java in the src folder, then java folder
	This class is used to save any constants that are used throughout the program
	No functional code should be placed in this class
	It is a conventient place to store the port numbers for wiring
The main.java file is where the robot instance is initialized
The majority of the robot should be built and declared in the RobotContainer.java class
	The robot's subsystems are defined at the top of this file (these are kept in the subsystems file
	The XBox controller instance is created here, with the input port being the parameter
		This information is held in the constants.java file
	RobotContainer is what holds all the commands for the robot to execute.
		Most of these commands will be in the form of functions that will be initialized later in the file
	ConfigureBindings is used to set up all binding configurations, with the paramater linking to a command in a specific subsystem
	The final function in this file is the getAutonmousCommand, which runs a command when Autonomous is entered
Subsystems can be created in the substsem folder in java under src
	This is where all the commands for that subsystem can be controlled
Specific commands can be created in the command folder which need to be linked to a specific subsystem


OUR ROBOT PLANS (I CAME UP WITH ALL BINDINGS, SUBJECT TO CHANGE):

A subsystem needs to be created for each system on the robot (More may need to be added as we add more functions to increase autonomous robot control):
	DriveTrain subsystem will control the wheels
	Arm subsystem will control the main lifting arm
	Claw will control whatever device is used for picking up game objects
Drivetrain system will need two main sets of functions:
	Translational:
		This uses the left stick of an XBox controller to move the robot in any direction without rotation
		Left Stick Forward: All wheels rotate forward
		Left Stick Backward: All wheels rotate backward
		Left Stick Left: Left side wheels spin towards each other, right side wheels spin away from one another
		Left Stick Right: Right side wheels spin towards each other, left side wheels spin away from each other
		Diagnol inputs will do the combined effects of the two directional inputs to the correct percentage of the X and Y components
	Rotational:
		These should be controlled by the left and right triggers in order to spin the robot about it's central axis
		Left Trigger: Right side wheel move forward while left side wheels spin backwards
		Right Trigger: Left wheels spin forward while right wheels spin backwards
Arm Subsytem:
	Egonomically, this makes most sense to be controlled by the right stick
	Right Stick Forward: arm lifts up (so arm winch would wind up)
	Right Stick Backward: arm lowers (so arm winch would unwind)
Claw Subsystem:
	This depends on how the claw works, however, this is a general outline:
	Y button: Claw closes
	A button: Claw opens
	If there is some sort of functionality that causes the claw to switch from pyramid mode to cube mode:
	X button: switch grabber functionality
With this setup, only about half the buttons on a standard XBox controller have binds
This means the other buttons can be bound to some autonomous function:
	B button: This can controller autonomous game piece movement
		If the claw is closed, then the robot knows when B is pressed it is supposed to automatically drop the piece off
		However, if the claw is open, it needs to automatically lower the arm and close the claw to pick up a piece

CONTROLLING THINGS:

All control changes need to be set up in subsystems and the RobotContainer file, however this begs the question of how
There are two main control things we need:
	Recognizing Controller Inputs:
		Buttons: m_driverController.b().whileTrue(m-exampleSubsystem.exampleMethodCommand());
			While Button B is being held down, examplemethodCommand() is being repeatedly executed
		Triggers: Same control system as buttons, using .LeftTriggerAxis instead of .b()
		Joysticks: Similar concept as buttons using .LeftStick, however concept of whilTrue I don't believe exists
	Spinning Motors:
		Depends on what motor controller is being used, but as and example for PWM controllers
			Spark spark = new Spark(); //0 is the RIO PWM port connection number
			spark.set(-0.75); //Output of the motor as a double between -1 and 1
		All motor movemens should occur in commands in the subsystems which are then brought into RrobotContainer where they are called on